Promise  and Future
===================

Promise is a companion type that allows you to complete a Future by putting a value into it.
Once a Promise has been completed, it’s not possible to change it any more.

A Promise instance is always linked to exactly one instance of Future. Promise --> have a -->Future. Promise is a wrapper for the Future.

Complte a Future
================
To complete a Promise with a success, you call its success method, passing it the value that the Future associated with. 

Once you call the promise.success(TaxCut(20)) that the Promise instance is no longer writable, 
and future attempts to do so will lead to an exception.

Usually, the completion of the Promise and the processing of the completed Future will not happen in the same thread. It’s more likely that 
you create your Promise, start computing its value in another thread and immediately return the uncompleted Future to the caller.

Calling the future method of a Promise multiple times will definitely always return the same object 
to make sure the one-to-one relationship between a Promise and its Future is preserved.

Example:
======== 
case class TaxCut(reduction: Int)
val taxcut: Promise[TaxCut] = Promise[TaxCut]()
val taxcutFuture: Future[TaxCut] = taxcut.future
taxcut.success(TaxCut(20))

Breaking a promise 
===================
val p = Promise[TaxCut]()
p.failure(LameExcuse("global economy crisis"))

Once you create a Future in REPL it will return a DefaultPromise
==================================================================

val f: Future[String] = Future { "Hello world!" }
// REPL output: 
// f: scala.concurrent.Future[String] = scala.concurrent.impl.Promise$DefaultPromise@793e6657

Example
=======
object Government {
  def redeemCampaignPledge(): Future[TaxCut] = {
    val p = Promise[TaxCut]()
    Future {
      println("Starting the new legislative period.")
      Thread.sleep(2000)
      // finsih a future by setting the future value in using the  p.success()
      p.success(TaxCut(20))
      println("We reduced the taxes! You must reelect us!!!!1111")
    }
    p.future
  }
}

val taxCutF: Future[TaxCut] = Government.redeemCampaignPledge()
println("Now that they're elected, let's see if they remember their promises...")
  taxCutF.onComplete {
    case Success(TaxCut(reduction)) =>
      println(s"A miracle! They really cut our taxes by $reduction percentage points!")
    case Failure(ex) =>
      println(s"They broke their promises! Again! Because of a ${ex.getMessage}")
  }
